-----
### CSRF (Cross Site Request Forgery, 사이트 간 위조 요청)
----
1. 웹 애플리케이션의 보안 취약점으로 공격자가 사용자로 하여금 이미 인증된 다른 사이트에 대해 원치 않는 작업을 수행하게 만드는 기법
2. 이 공격은 사용자의 브라우저가 자동으로 보낼 수 있는 인증 정보(예를 들어, 쿠키나 기본 인증 세션)를 이용하여 사용자가 의도하지 않는 요청을 서버로 전송하게 만듬
3. 이는 사용자가 로그인한 상태에서 악의적인 웹 사이트를 방문하거나 이메일 등을 통해 악의적인 링크를 클릭할 때 발생할 수 있음

-----
### CSRF 진행 순서
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/3896ad02-7ad0-419c-b6b5-9920be36c8de">
</div>

-----
### CSRF 기능 활성화
-----
```java
@Bean
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
    http.csrf(Customizer.withDefaults()); // CSRF의 기능 활성화 (별도 설정하지 않아도 활성화 상태로 초기화)
    return http.build():
}
```

1. 토큰은 서버에 의해 생성되어 클라이언트의 세션에 저장되고 폼을 통해 서버로 전송되는 모든 변경 요청에 포함되어야 하며 서버는 이 토큰을 검증하여 요청의 유효성을 확인
2. 기본 설정은 'PUT', 'HEAD', 'TRACE', 'OPTIONS'와 같은 안전한 메서드를 무시하고, 'POST', 'PUT', 'DELETE'와 같은 변경 요청 메서드에서만 CSRF 토큰 검사 수행
3. 중요한 점은 실제 CSRF 토큰이 브라우저에 의해 자동으로 포함되지 않는 요청 부분에 위치해야 한다는 것으로서, HTTP 매개변수나 헤더에 실제 CSRF 토큰을 요구하는 것이 CSRF 공격을 방지하는데 효과적
4. 반면에 쿠키에 토큰을 요구하는 것은 브라우저가 쿠키를 자동으로 요청에 포함시키기 때문에 효과적이지 않다고 볼 수 있음

-----
### CSRF 기능 비활성화
-----
1. CSRF 기능 전체 비활성화
```java
@Bean
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
    http.csrf(csrf -> csrf.disabled());
    return http.build():
}
```

2. CSRF 보호가 필요하지 않은 특정 엔드포인트만 비활성화
```java
@Bean
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {
    http.csrf(csrf -> csrf.ignoringRequestMatchers("/api/*")); 
    return http.build():
}
```

-----
### 코드
-----
1. SecurityConfig
```java
package io.security.springsecuritymaster;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/csrf").permitAll()
                        .anyRequest().authenticated())
                .formLogin(Customizer.withDefaults()); // 기본 CSRF 기본 활성화

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("user")
                .password("{noop}1111")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }
}
```

2. csrf.http
```http
### POST request with a header
POST http://localhost:9090/csrf
Content-Type: application/json

### POST request with a header
POST http://localhost:9090/csrf
Content-Type: application/x-www-form-urlencoded

_csrf = Pt5VPqupKhJ_XIZBWuUjCbiRMndV7JU-eFu4CXtUu_thUbdcC-wwWp-cGXFSbrAjasgXPIujHxVl3KYTTW_dMR9l3cxUZ4I6

### Send POST request with json body
POST http://localhost:9090/ignoreCsrf
Content-Type: application/json
```

3. IndexController
```java
package io.security.springsecuritymaster;

import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.annotation.CurrentSecurityContext;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class IndexController {
    @GetMapping("/")
    public Authentication index(Authentication authentication) {
        return authentication;
    }

    @GetMapping("/loginPage")
    public String loginPage() {
        return "loginPage";
    }

    @GetMapping("/home")
    public String home() {
        return "home";
    }

    @GetMapping("/anonymous")
    public String anonymous() {
        return "anonymous"; // 권한을 가진 후 접근하려하면, 접근 불가 (이미 인증을 받았으므로)
    }

    @GetMapping("/authentication")
    public String authentication(Authentication authentication) { // Authentication 객체를 파라미터로 받음 (익명 객체를 참조받지 못하고 있음)
        if(authentication instanceof AnonymousAuthenticationToken) { // 익명 사용자 객체라면,
            return "anonymous";
        } else { // 아니라면, Null이므로 익명 객체 참조 불가
            return "not anonymous";
        }
    }

    @GetMapping("/anonymousContext") // 익명 객체 참조
    public String anonymousContext(@CurrentSecurityContext SecurityContext securityContext) {
        return securityContext.getAuthentication().getName(); // 현재 SecurityContext에서 익명 객체를 참조 받아 사용
    }

    @GetMapping("/logoutSuccess")
    public String logoutSuccess() {
        return "logoutSuccess";
    }

    @GetMapping("/invalidSessionUrl")
    public String invalidSessionUrl() {
        return "invalidSessionUrl";
    }

    @GetMapping("/expiredUrl")
    public String expiredUrl() {
        return "expiredUrl";
    }

    @GetMapping("/login")
    public String login() {
        return "login";
    }

    @GetMapping("/denied")
    public String denied() {
        return "denied";
    }

    @PostMapping("/csrf")
    public String csrf() {
        return "csrf 적용됨";
    }
}
```

4. 결과
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">
    <title>Please sign in</title>
    <link href="/default-ui.css" rel="stylesheet"/>
</head>
<body>
<div class="content">
    <form class="login-form" method="post" action="/login">
        <h2>Please sign in</h2>

        <p>
            <label for="username" class="screenreader">Username</label>
            <input type="text" id="username" name="username" placeholder="Username" required autofocus>
        </p>
        <p>
            <label for="password" class="screenreader">Password</label>
            <input type="password" id="password" name="password" placeholder="Password" required>
        </p>

        <!-- CSRF 토큰 내부적으로 서버가 생성한 토큰을 input에 추가 -->
        <input name="_csrf" type="hidden"
               value="Pt5VPqupKhJ_XIZBWuUjCbiRMndV7JU-eFu4CXtUu_thUbdcC-wwWp-cGXFSbrAjasgXPIujHxVl3KYTTW_dMR9l3cxUZ4I6"/>
        <button type="submit" class="primary">Sign in</button>
    </form>


</div>
</body>
</html>
```

5. CSRF 토큰 적용 후 결과
```
csrf 적용됨
```

6. CSRF 비활성화
   - SecurityConfig
```java
package io.security.springsecuritymaster;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/csrf").permitAll()
                        .anyRequest().authenticated())
                .formLogin(Customizer.withDefaults())
                .csrf(csrf -> csrf.disable()); // CSRF 비활성화

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("user")
                .password("{noop}1111")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }
}
```

```
csrf 적용됨
```

7. 특정 URL만 비활성화
   - SecurityConfig
```java
package io.security.springsecuritymaster;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/csrf").permitAll()
                        .anyRequest().authenticated())
                .formLogin(Customizer.withDefaults())
                .csrf(csrf -> csrf.ignoringRequestMatchers("/csrf")); // /CSRF/.. URL만 비활성화

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("user")
                .password("{noop}1111")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }
}
```

```
csrf 적용됨
```
