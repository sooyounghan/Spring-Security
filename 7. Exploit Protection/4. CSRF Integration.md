-----
### 개요
-----
1. CSRF 공격을 방지하기 위한 토큰 패턴을 사용하려면 실제 CSRF 토큰을 HTTP 요청에 포함해야 함
2. 따라서, 브라우저에 의해 HTTP 요청에 자동으로 포함되지 않는 요청 부분 (폼 매개변수, HTTP 헤더 또는 기타 부분) 중 하나에 포함되어야 함

-----
### HTML Forms
-----
1. HTML 폼을 서버에 제출하려면 CSRF 토큰을 hidden 값으로 FORM에 포함해야 함
```html
<form action="/memberJoin" method="post">
<input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>
</form>

<input type="hidden" name="_csrf" value="4bfd1575-3ad1-4d21-96c7-4ef2d9f86721"/>
```

2. 폼에 실제 CSRF 토큰을 자동으로 포함하는 뷰
   - Thymeleaf
   - Spring 폼 태그 라이브러리 - ```<% @taglib prefix="form" uri="http://www.springframework.org/tags/form" %>```

-----
### JavaScript Applications
-----
1. Single Page Application
   - CookieCsrfTokenRepository.withHttpOnlyFalse를 사용해서 클라이언트가 서버가 발행한 쿠키로부터 CSRF 토큰을 읽을 수 있도록 함
   - 사용자 정의 CsrfTokenRequestHandler를 만들어 클라이언트가 요청 헤더나 요청 파라미터로 CSRF 토큰을 제출할 경우 이를 검증하도록 구현
   - 클라이언트 요청에 대해 CSRF 토큰을 쿠키에 렌더링해서 응답할 수 있도록 필터를 구현

<div align="center">
<img src="https://github.com/user-attachments/assets/4bd46c3d-a295-432c-b282-88f38ae78e91">
</div>

2. Multi Page Application
   - JavaScript가 각 페이지에서 로드되는 멀티 페이지 애플리케이션의 경우, CSRF 토큰을 쿠키에 노출시키는 대신 HTML 메타 태그 내 CSRF 토큰을 포함시킬 수 있음
   - HTML 메타 태그에 CSRF 토큰 포함
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<meta name="_csrf" th:content="${_csrf.token}"/>
<meta name ="_csrf_header" th:content="${_csrf.headerName}"/>
</html>
```

  - AJAX 요청에서 CSRF 토큰 포함
```js
function login() {
    const csrfHeader = ${'meta[name="_csrf_header"]').attr('content');
    const csrfToken = ${'meta[name="_csrf"]').attr('content');

    fetch('/api/login', {
        method: 'POST',
        headers: {[csrfHeader]: csrfToken }
    })
}
```

-----
### 코드
-----
1. form.html
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <title>Dashboard</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #ffffff; /* 밝은 배경색 변경 */
            color: #000000; /* 어두운 글자색 변경 */
        }
        .navbar-custom {
            background-color: #ffffff; /* 밝은 네이비 변경 */
            color: #000000;
            margin-bottom: 0;
        }
        .container-fluid {
            padding: 0; /* container의 패딩 제거 */
        }
        .navbar-custom .navbar-brand, .navbar-custom .nav-link {
            color: #000000;
        }
        .sidebar {
            background-color: #ffffff; /* 밝은 네이비 변경 */
            min-height: 100vh;
            color: #000000;
        }
        .sidebar a {
            color: #000000;
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .sidebar a:hover {
            background-color: #cccccc; /* 마우스 오버시 밝은 회색 */
            color: #000000;
        }
        .content {
            padding: 20px;
            background-color: #ffffff; /* 밝은 그레이 변경 */
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1); /* 박스 그림자 색상 변경 */
            margin-top: 0;
        }
        .footer {
            background-color: #ffffff; /* 밝은 네이비 변경 */
            color: #000000;
            padding: 10px 0;
            border-top: 1px solid #cccccc; /* 경계선 색상 변경 */
        }
        .sidebar .list-group-item {
            color: #000000; /* 글자색 변경 */
            background-color: #ffffff; /* 배경색 변경 */
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .sidebar .list-group-item:hover {
            background-color: #cccccc; /* 마우스 오버시 밝은 회색 */
            color: #000000;
        }
        /* 중앙 로그인 폼 스타일 변경 */
        .login-form {
            max-width: 400px;
            margin: 30px auto;
            padding: 20px;
            background-color: #ffffff; /* 밝은 폼 배경색 변경 */
            border-radius: 5px;
            border: 1px solid #000000; /* 검은색 테두리 추가 */
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.1); /* 박스 그림자 색상 변경 */
        }
        .login-form h2 {
            color: #000000; /* 어두운 글자색 변경 */
            margin-bottom: 20px;
        }
        .login-form .form-control {
            background-color: #ffffff; /* 밝은 입력 필드 배경색 변경 */
            color: #000000; /* 어두운 입력 필드 글자색 변경 */
            border: 1px solid #cccccc; /* 입력 필드 경계선 색상 변경 */
        }
        .login-form .btn-primary {
            background-color: #4e73df; /* 밝은 버튼 색상 유지 */
            border: none;
        }
    </style>
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"></script>
</head>
<body>
<div class="container-fluid">
    <div class="row">
        <div class="col-md-10 content">
            <div class="login-form">
                <form th:action="@{/formCsrf}" method="post"> // Thymeleaf 문법에 의해 CSRF 토큰 생성
                    <div class="form-group">
                        <label for="username">Username</label>
                        <input type="text" class="form-control" id="username" name="username" required>
                    </div>
                    <div class="form-group">
                        <label for="password">Password</label>
                        <input type="password" class="form-control" id="password" name="password" required>
                    </div>
                    <button type="submit" class="btn btn-primary">Login</button>
                </form>
            </div>
        </div>
    </div>
</div>
</body>
</html>
```

2. cookie.html
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <title>Fetch Example</title>
  <script>
    // fetch 요청을 실행하는 함수
    function sendRequest() {
      fetch('/cookieCsrf', {
        method: 'POST', // 요청 메소드
        headers: {
          'Content-Type': 'application/json', // 컨텐츠 타입 지정
          'X-XSRF-TOKEN': getCookie('XSRF-TOKEN') // CSRF 토큰 헤더에 추가
        },
        body: JSON.stringify({/* 데이터 객체 */}), // 서버로 보낼 데이터
        credentials: 'include' // 쿠키를 포함시키기 위해 필요
      })
              .then(response => {
                if (!response.ok) {
                  throw new Error('Network response was not ok');
                }
                return response.json(); // 여기에서 서버 응답을 처리
              })
              .then(data => {
                console.log('Success:', data); // 성공 처리 로직
              })
              .catch(error => {
                console.error('Error:', error); // 에러 처리 로직
              });
    }

    // 쿠키 값을 가져오는 함수
    function getCookie(name) {
      let cookieValue = null;
      if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
          const cookie = cookies[i].trim();
          if (cookie.substring(0, name.length + 1) === (name + '=')) {
            cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
            break;
          }
        }
      }
      return cookieValue;
    }
  </script>
</head>
<body>
<!-- 버튼 요소 -->
<button onclick="sendRequest()">Send Request</button>
</body>
</html>
```

3. SecurityConfig
```java
package io.security.springsecuritymaster;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.XorCsrfTokenRequestAttributeHandler;

@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/csrf", "/csrfToken", "/form", "/formCsrf").permitAll()
                        .anyRequest().authenticated())
                .formLogin(Customizer.withDefaults())
                .csrf(Customizer.withDefaults());

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("user")
                .password("{noop}1111")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }
}
```

4. ViewController
```java
package io.security.springsecuritymaster;

import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

@Controller
public class ViewController {
    @GetMapping("/form")
    public String form() {
        return "form";
    }
}
```

5. IndexController
```java
package io.security.springsecuritymaster;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.annotation.CurrentSecurityContext;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class IndexController {
  @GetMapping("/")
  public Authentication index(Authentication authentication) {
      return authentication;
  }

  @GetMapping("/loginPage")
  public String loginPage() {
      return "loginPage";
  }

  @GetMapping("/home")
  public String home() {
      return "home";
  }

  @GetMapping("/anonymous")
  public String anonymous() {
      return "anonymous"; // 권한을 가진 후 접근하려하면, 접근 불가 (이미 인증을 받았으므로)
  }

  @GetMapping("/authentication")
  public String authentication(Authentication authentication) { // Authentication 객체를 파라미터로 받음 (익명 객체를 참조받지 못하고 있음)
      if(authentication instanceof AnonymousAuthenticationToken) { // 익명 사용자 객체라면,
          return "anonymous";
      } else { // 아니라면, Null이므로 익명 객체 참조 불가
          return "not anonymous";
      }
  }

  @GetMapping("/anonymousContext") // 익명 객체 참조
  public String anonymousContext(@CurrentSecurityContext SecurityContext securityContext) {
      return securityContext.getAuthentication().getName(); // 현재 SecurityContext에서 익명 객체를 참조 받아 사용
  }

  @GetMapping("/logoutSuccess")
  public String logoutSuccess() {
      return "logoutSuccess";
  }

  @GetMapping("/invalidSessionUrl")
  public String invalidSessionUrl() {
      return "invalidSessionUrl";
  }

  @GetMapping("/expiredUrl")
  public String expiredUrl() {
      return "expiredUrl";
  }

  @GetMapping("/login")
  public String login() {
      return "login";
  }

  @GetMapping("/denied")
  public String denied() {
      return "denied";
  }

  @PostMapping("/csrf")
  public String csrf() {
      return "csrf 적용됨";
  }

  @GetMapping("/csrfToken")
  public String csrfToken(HttpServletRequest request) {
      CsrfToken csrfToken1 = (CsrfToken) request.getAttribute(CsrfToken.class.getName()); // HEADER NAME으로 가져옴
      CsrfToken csrfToken2 = (CsrfToken) request.getAttribute("_csrf"); // Parameter Name으로 가져옴
      // 지연된 CsrfTokenRepository에서 위 요청 시 가져옴

      String token = csrfToken1.getToken();

      return token;
  }

  @PostMapping("/formCsrf")
  public CsrfToken formCsrf(CsrfToken csrfToken) {
      return csrfToken;
  }
}
```

6. http://localhost:9090/form
<div align="center">
<img src="https://github.com/user-attachments/assets/08b5b19c-b108-456c-9cfe-988b881ea5a8">
</div>

7. JavaScript 이용
   - SecurityConfig
```java
package io.security.springsecuritymaster;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;
import org.springframework.security.web.csrf.CookieCsrfTokenRepository;
import org.springframework.security.web.csrf.XorCsrfTokenRequestAttributeHandler;

@EnableWebSecurity
@Configuration
public class SecurityConfig {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        SpaCsrfTokenRequestHandler spaCsrfTokenRequestHandler = new SpaCsrfTokenRequestHandler();
        
        http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/csrf", "/csrfToken", "/cookie", "/cookieCsrf").permitAll()
                        .anyRequest().authenticated())
                .formLogin(Customizer.withDefaults())
                .csrf(csrf -> csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                        .csrfTokenRequestHandler(spaCsrfTokenRequestHandler))
                .addFilterBefore(new CsrfCookieFilter(), BasicAuthenticationFilter.class); // BasicAuthenticationFilter 전에 필터 적용

        return http.build();
    }

    /*
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/csrf", "/csrfToken", "/form", "/formCsrf").permitAll()
                        .anyRequest().authenticated())
                .formLogin(Customizer.withDefaults())
                .csrf(Customizer.withDefaults());

        return http.build();
    }
    */

    @Bean
    public UserDetailsService userDetailsService() {
        UserDetails user = User.withUsername("user")
                .password("{noop}1111")
                .roles("USER")
                .build();

        return new InMemoryUserDetailsManager(user);
    }
}
```

   - SpaCsrfTokenRequestHandler
```java
package io.security.springsecuritymaster;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.security.web.csrf.CsrfTokenRequestAttributeHandler;
import org.springframework.security.web.csrf.XorCsrfTokenRequestAttributeHandler;
import org.springframework.util.StringUtils;

import java.util.function.Supplier;

public class SpaCsrfTokenRequestHandler extends CsrfTokenRequestAttributeHandler {
    
    // 인코딩, 디코딩 처리
    private final CsrfTokenRequestAttributeHandler delegate = new XorCsrfTokenRequestAttributeHandler();

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, Supplier<CsrfToken> deferredCsrfToken) {
        delegate.handle(request, response, deferredCsrfToken); // 기본 구현체에서 CSRF 토큰 처리
    }

    @Override
    public String resolveCsrfTokenValue(HttpServletRequest request, CsrfToken csrfToken) {
        if(StringUtils.hasText(request.getHeader(csrfToken.getHeaderName()))) { // Header에 CSRF 토큰이 있다면, 즉, 헤더가 있다면 (인코딩 된 것이 아니라면)
            return super.resolveCsrfTokenValue(request, csrfToken); // CsrfTokenRequestAttributeHandler가 처리
        }
        
        return delegate.resolveCsrfTokenValue(request, csrfToken); // XorCsrfTokenRequestAttributeHandler가 디코딩해서 처리
    }
}
```

   - CsrfCookieFilter
```java
package io.security.springsecuritymaster;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

public class CsrfCookieFilter extends OncePerRequestFilter {
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        CsrfToken csrfToken = (CsrfToken) request.getAttribute("_csrf");// 지연된 토큰 가져오기
        
        if(csrfToken != null) {
            csrfToken.getToken(); // 토큰 렌더링
        }
        
        filterChain.doFilter(request, response);
    }
}
```

   - ViewController
```java
package io.security.springsecuritymaster;

import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

@Controller
public class ViewController {
    @GetMapping("/form")
    public String form() {
        return "form";
    }

    @GetMapping("/cookie")
    public String cookie() {
        return "cookie";
    }
}
```

   - IndexController
```java
package io.security.springsecuritymaster;

import jakarta.servlet.http.HttpServletRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AnonymousAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.annotation.CurrentSecurityContext;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.web.csrf.CsrfToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class IndexController {
  @GetMapping("/")
  public Authentication index(Authentication authentication) {
      return authentication;
  }

  @GetMapping("/loginPage")
  public String loginPage() {
      return "loginPage";
  }

  @GetMapping("/home")
  public String home() {
      return "home";
  }

  @GetMapping("/anonymous")
  public String anonymous() {
      return "anonymous"; // 권한을 가진 후 접근하려하면, 접근 불가 (이미 인증을 받았으므로)
  }

  @GetMapping("/authentication")
  public String authentication(Authentication authentication) { // Authentication 객체를 파라미터로 받음 (익명 객체를 참조받지 못하고 있음)
      if(authentication instanceof AnonymousAuthenticationToken) { // 익명 사용자 객체라면,
          return "anonymous";
      } else { // 아니라면, Null이므로 익명 객체 참조 불가
          return "not anonymous";
      }
  }

  @GetMapping("/anonymousContext") // 익명 객체 참조
  public String anonymousContext(@CurrentSecurityContext SecurityContext securityContext) {
      return securityContext.getAuthentication().getName(); // 현재 SecurityContext에서 익명 객체를 참조 받아 사용
  }

  @GetMapping("/logoutSuccess")
  public String logoutSuccess() {
      return "logoutSuccess";
  }

  @GetMapping("/invalidSessionUrl")
  public String invalidSessionUrl() {
      return "invalidSessionUrl";
  }

  @GetMapping("/expiredUrl")
  public String expiredUrl() {
      return "expiredUrl";
  }

  @GetMapping("/login")
  public String login() {
      return "login";
  }

  @GetMapping("/denied")
  public String denied() {
      return "denied";
  }

  @PostMapping("/csrf")
  public String csrf() {
      return "csrf 적용됨";
  }

  @GetMapping("/csrfToken")
  public String csrfToken(HttpServletRequest request) {
      CsrfToken csrfToken1 = (CsrfToken) request.getAttribute(CsrfToken.class.getName()); // HEADER NAME으로 가져옴
      CsrfToken csrfToken2 = (CsrfToken) request.getAttribute("_csrf"); // Parameter Name으로 가져옴
      // 지연된 CsrfTokenRepository에서 위 요청 시 가져옴

      String token = csrfToken1.getToken();

      return token;
  }

  @PostMapping("/formCsrf")
  public CsrfToken formCsrf(CsrfToken csrfToken) {
      return csrfToken;
  }

  @PostMapping("/cookieCsrf")
  public CsrfToken cookieCsrf(CsrfToken csrfToken) {
      return csrfToken;
  }
}
```
