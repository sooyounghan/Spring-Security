-----
### CSRF 토큰 유지 - CsrfTokenRepository
-----
1. CsrfToken은 CsrfTokenRepository를 사용하여 영속화하며, HttpSessionCsrfTokenRepository와 CookieCsrfTokenRepository를 지원
2. 두 군데 중 원하는 위치에 토큰을 저장하도록 설정을 통해 지정 가능

3. 세션에 토큰 저장 - HttpSessionCsrfTokenRepository
```java
@Bean
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {

    HttpSessionCsrfTokenRepository repository = new HttpSessionCsrfTokenRepository();
    http.csrf(csrf -> csrf.csrfTokenRepository(repository));

    return http.build();
}
```
  - 기본적으로 토큰을 세션에 저장하기 위해 HttpSessionCsrfTokenRepository를 사용
  - HttpSessionCsrfTokenRepository는 기본적으로 HTTP 요청 헤더인 X-CSRF-TOKEN 또는 요청 매개변수인 _csrf에서 토큰을 읽음
<div align="center">
<img src="https://github.com/user-attachments/assets/8e836094-34b2-458f-b034-3292b2f8143d">
</div>

4. 쿠키에 토큰 저장 - CookieCsrfTokenRepository
```java
@Bean
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {

    CookieCsrfTokenRepository repository = new CookieCsrfTokenRepository();
    http.csrf(csrf -> csrf.csrfTokenRepository(repository));
    http.csrf(csrf -> csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());

    return http.build();
}
```
  - JavaScript 기반 애플리케이션 지원을 위해 CsrfToken을 쿠키에 유지할 수 있으며 구현체로 CookieCsrfTokenRepository를 사용
  - CookieCsrfTokenRepository는 기본적으로 XSRF-TOKEN 명을 가진 쿠키에 작성하고, HTTP 요청 헤더인 X-XSRF-TOKEN 또는 요청 매개변수인 _csrf에서 읽음
<div align="center">
<img src="https://github.com/user-attachments/assets/648ba454-8898-4ccf-80f0-8bf0037a3007">
</div>

  - JavaScript에서 쿠키를 읽을 수 있도록 HttpOnly를 명시적으로 false로 설정
  - JavaScript로 직접 쿠키를 읽을 필요가 없는 경우 보안을 개선하기 위해 HttpOnly를 생략하는 것이 좋음

-----
### CSRF 토큰 처리 - CsrfTokenRequestHandler
-----
1. CsrfToken은 CsrfTokenRequestHandler를 사용하여 토큰을 생성 및 응답하고 HTTP 헤더 또는 요청 매개변수로부터 토큰의 유효성을 검증하도록 함
2. XorCsrfTokenRequestAttributeHandler와 CsrfTokenRequestAttributeHandler를 제공하며 사용자 정의 핸들러를 구현할 수 있음
```java
@Bean
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {

    XorCsrfTokenRequestAttributeHandler csrfTokenHandler = new XorCsrfTokenRequestAttributeHandler();
    http.csrf(csrf -> csrf.csrfTokenRequestHandler(csrfTokenHandlder));

    return http.build();
}
```

  - "_csrf" 및 CsrfToken.class.getName() 명으로 HttpServletRequest 속성에 CsrfToken을 저장하며 HttpServletRequest로부터 CsrfToken을 꺼내어 참조할 수 있음
  - 토큰 값을 요청 헤더 (기본적으로 X-CSRF-TOKEN 또는 X-XSRF-TOKEN 중 하나) 또는 요청 매개변수(_csrf) 중 하나로부터 토큰의 유효성 비교 및 검증을 해결
  - 클라이언트의 매 요청마다 CSRF 토큰 값(UUID)에 난수를 인코딩하여 변경한 CsrfToken이 반환되도록 보장하며, 세션에 저장된 원본 토큰 값은 그대로 유지
  - 헤더 값 또는 요청 매개변수로 전달된 인코딩 된 토큰은 원본 토큰을 얻기 위해 디코딩되며, 그런 다음 세션 혹은 쿠키에 저장된 영구적인 CsrfToken과 비교됨

-----
### CSRF 토큰 지연 로딩
-----
1. 기본적으로 Spring Security는 CsrfToken을 필요할 때 까지 로딩을 지연시키는 전략을 사용
2. 그러므로 CsrfToken은 HttpSession에 저장되어 있기 때문에 매 요청마다 세션으로부터 CsrfToken을 로드할 필요가 없어져 성능을 향상시킬 수 있음
3. CsrfToken은 POST와 같은 안전하지 않은 HTTP 메서드를 사용하여 요청이 발생할 때와 CSRF 토큰을 응답에 렌더링하는 모든 요청에서 필요하기 때문에 그 외 요청에는 지연 로딩하는 것이 권장
```java
@Bean
SecurityFilterChain defaultSecurityFilterChain(HttpSecurity http) throws Exception {

    XorCsrfTokenRequestAttributeHandler handler = new XorCsrfTokenRequestAttributeHandler();
    handler.setCsrfRequestAttributeName(null); // 지연된 토큰을 사용하지 않고 CsrfToken을 매 요청마다 로드

    http.csrf(csrf -> csrf
        .csrfTokenRequestHandler(handler));

    return http.build();
}
```

-----
### 코드
-----
1. GET 방식 요청
   - csrf.http
```http
### GET request with a header
GET http://localhost:9090
Accept: application/json
```

   - CsrfFilter
```java
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        DeferredCsrfToken deferredCsrfToken = this.tokenRepository.loadDeferredToken(request, response);
        request.setAttribute(DeferredCsrfToken.class.getName(), deferredCsrfToken);
        CsrfTokenRequestHandler var10000 = this.requestHandler;
        Objects.requireNonNull(deferredCsrfToken);
        var10000.handle(request, response, deferredCsrfToken::get);
        if (!this.requireCsrfProtectionMatcher.matches(request)) { // Request 객체로부터 정보 비교
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Did not protect against CSRF since request did not match " + this.requireCsrfProtectionMatcher);
            }

            filterChain.doFilter(request, response);
        } else {
            CsrfToken csrfToken = deferredCsrfToken.get();
            String actualToken = this.requestHandler.resolveCsrfTokenValue(request, csrfToken);
            if (!equalsConstantTime(csrfToken.getToken(), actualToken)) {
                boolean missingToken = deferredCsrfToken.isGenerated();
                this.logger.debug(LogMessage.of(() -> {
                    return "Invalid CSRF token found for " + UrlUtils.buildFullRequestUrl(request);
                }));
                AccessDeniedException exception = !missingToken ? new InvalidCsrfTokenException(csrfToken, actualToken) : new MissingCsrfTokenException(actualToken);
                this.accessDeniedHandler.handle(request, response, (AccessDeniedException)exception);
            } else {
                filterChain.doFilter(request, response);
            }
        }
}

private static final class DefaultRequiresCsrfMatcher implements RequestMatcher {
        private final HashSet<String> allowedMethods = new HashSet(Arrays.asList("GET", "HEAD", "TRACE", "OPTIONS"));

        private DefaultRequiresCsrfMatcher() {
        }

        public boolean matches(HttpServletRequest request) {
            return !this.allowedMethods.contains(request.getMethod()); // Request가 보낸 요청 방식 확인
        }

        public String toString() {
            return "CsrfNotRequired " + this.allowedMethods;
        }
}
```

2. POST 방식
```http
### POST request with a header
POST http://localhost:9090/csrf
Content-Type: application/json

```

   - CsrfFilter
```java
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        DeferredCsrfToken deferredCsrfToken = this.tokenRepository.loadDeferredToken(request, response); // RepositoryDeferredCsrfToken
        request.setAttribute(DeferredCsrfToken.class.getName(), deferredCsrfToken); // 해당 토큰을 Request에 저장
        CsrfTokenRequestHandler var10000 = this.requestHandler; // XorCsrfTokenRequestAttributeHandler
        Objects.requireNonNull(deferredCsrfToken);
        var10000.handle(request, response, deferredCsrfToken::get);
        if (!this.requireCsrfProtectionMatcher.matches(request)) { // Request 객체로부터 정보 비교
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Did not protect against CSRF since request did not match " + this.requireCsrfProtectionMatcher);
            }

            filterChain.doFilter(request, response);
        } else { // POST, DELETE, PUT
            CsrfToken csrfToken = deferredCsrfToken.get();
            String actualToken = this.requestHandler.resolveCsrfTokenValue(request, csrfToken); // XorCsrfTokenRequestAttributeHandler의 resolveCsrfTokenValue
            if (!equalsConstantTime(csrfToken.getToken(), actualToken)) {
                boolean missingToken = deferredCsrfToken.isGenerated();
                this.logger.debug(LogMessage.of(() -> {
                    return "Invalid CSRF token found for " + UrlUtils.buildFullRequestUrl(request);
                }));
                AccessDeniedException exception = !missingToken ? new InvalidCsrfTokenException(csrfToken, actualToken) : new MissingCsrfTokenException(actualToken);
                this.accessDeniedHandler.handle(request, response, (AccessDeniedException)exception);
            } else {
                filterChain.doFilter(request, response);
            }
        }
}

private static final class DefaultRequiresCsrfMatcher implements RequestMatcher {
        private final HashSet<String> allowedMethods = new HashSet(Arrays.asList("GET", "HEAD", "TRACE", "OPTIONS"));

        private DefaultRequiresCsrfMatcher() {
        }

        public boolean matches(HttpServletRequest request) {
            return !this.allowedMethods.contains(request.getMethod()); // Request가 보낸 요청 방식 확인
        }

        public String toString() {
            return "CsrfNotRequired " + this.allowedMethods;
        }
}
```

  - DefferedCsrfToken
```java
package org.springframework.security.web.csrf;

public interface DeferredCsrfToken {
    CsrfToken get();

    boolean isGenerated();
}
```

  - 구현체 : RepositoryDeferredCsrfToken
```java
package org.springframework.security.web.csrf;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

final class RepositoryDeferredCsrfToken implements DeferredCsrfToken {
    private final CsrfTokenRepository csrfTokenRepository;
    private final HttpServletRequest request;
    private final HttpServletResponse response;
    private CsrfToken csrfToken; // 실제 CSRF 토큰 값을 가지고 있음
    private boolean missingToken;

    RepositoryDeferredCsrfToken(CsrfTokenRepository csrfTokenRepository, HttpServletRequest request, HttpServletResponse response) {
        this.csrfTokenRepository = csrfTokenRepository;
        this.request = request;
        this.response = response;
    }

    public CsrfToken get() { // get 메서드를 통해 초기화 실행
        this.init();
        return this.csrfToken;
    }

    public boolean isGenerated() {
        this.init();
        return this.missingToken;
    }

    private void init() {
        if (this.csrfToken == null) {
            this.csrfToken = this.csrfTokenRepository.loadToken(this.request); // Request 객체에서 불러오기
            this.missingToken = this.csrfToken == null;
            if (this.missingToken) {
                this.csrfToken = this.csrfTokenRepository.generateToken(this.request); // 토큰 생성
                this.csrfTokenRepository.saveToken(this.csrfToken, this.request, this.response); // 세션에 저장
            }

        }
    }
}
```

  - HttpSessionCsrfTokenRepository
```java
public CsrfToken loadToken(HttpServletRequest request) {
        HttpSession session = request.getSession(false);
        return session == null ? null : (CsrfToken)session.getAttribute(this.sessionAttributeName);
    }

    public CsrfToken generateToken(HttpServletRequest request) {
        return new DefaultCsrfToken(this.headerName, this.parameterName, this.createNewToken()); // X-CSRF-TOKEN, x_csrf


    private String createNewToken() {
        return UUID.randomUUID().toString();
    }
}
```

  - CsrfTokenRequestHandler 구현체 : XorCsrfTokenRequestAttributeHandler
```java
public void handle(HttpServletRequest request, HttpServletResponse response, Supplier<CsrfToken> deferredCsrfToken) {
    Assert.notNull(request, "request cannot be null");
    Assert.notNull(response, "response cannot be null");
    Assert.notNull(deferredCsrfToken, "deferredCsrfToken cannot be null");
    Supplier<CsrfToken> updatedCsrfToken = this.deferCsrfTokenUpdate(deferredCsrfToken); // 최대한 실행 시점 지연
    super.handle(request, response, updatedCsrfToken);
}

private Supplier<CsrfToken> deferCsrfTokenUpdate(Supplier<CsrfToken> csrfTokenSupplier) { // 최대한 실행 시점 지연
        return new CachedCsrfTokenSupplier(() -> {
            CsrfToken csrfToken = (CsrfToken)csrfTokenSupplier.get();
            Assert.state(csrfToken != null, "csrfToken supplier returned null");
            String updatedToken = createXoredCsrfToken(this.secureRandom, csrfToken.getToken()); 
            return new DefaultCsrfToken(csrfToken.getHeaderName(), csrfToken.getParameterName(), updatedToken);
        });
}

public String resolveCsrfTokenValue(HttpServletRequest request, CsrfToken csrfToken) {
        String actualToken = super.resolveCsrfTokenValue(request, csrfToken); // CsrfTokenRequestHandler
        return getTokenValue(actualToken, csrfToken.getToken());
}
```

  -  CsrfTokenRequestHandler 인터페이스
```java
default String resolveCsrfTokenValue(HttpServletRequest request, CsrfToken csrfToken) {
        Assert.notNull(request, "request cannot be null");
        Assert.notNull(csrfToken, "csrfToken cannot be null");
        String actualToken = request.getHeader(csrfToken.getHeaderName()); // Header 이름으로 얻어오기 (X-CSRF-TOKEN)
        if (actualToken == null) {
            actualToken = request.getParameter(csrfToken.getParameterName()); // Header가 없다면 Parameter(_csrf)
        }

        return actualToken;
}
```

  -  CsrfTokenRequestHandler 구현체 : CsrfTokenRequestAttributeHandler (XorCsrfTokenRequestAttributeHandler 부모 클래스)
```java
public void handle(HttpServletRequest request, HttpServletResponse response, Supplier<CsrfToken> deferredCsrfToken) {
        Assert.notNull(request, "request cannot be null");
        Assert.notNull(response, "response cannot be null");
        Assert.notNull(deferredCsrfToken, "deferredCsrfToken cannot be null");
        request.setAttribute(HttpServletResponse.class.getName(), response);
        CsrfToken csrfToken = new SupplierCsrfToken(deferredCsrfToken); // 지연된 토큰
        request.setAttribute(CsrfToken.class.getName(), csrfToken); // Request 객체에 CsrfToken의 이름으로 저장
        String csrfAttrName = this.csrfRequestAttributeName != null ? this.csrfRequestAttributeName : csrfToken.getParameterName();
        request.setAttribute(csrfAttrName, csrfToken); // _csrf라는 문자열로 토큰 저장
}
```

  - Csrf 토큰 구현체 : DefaultCsrfToken
```java
package org.springframework.security.web.csrf;

import org.springframework.util.Assert;

public final class DefaultCsrfToken implements CsrfToken {
    private final String token; // 문자열로 저장된 토큰 값
    private final String parameterName; // 파라미터로 검색
    private final String headerName; // 헤더로 검색

    public DefaultCsrfToken(String headerName, String parameterName, String token) {
        Assert.hasLength(headerName, "headerName cannot be null or empty");
        Assert.hasLength(parameterName, "parameterName cannot be null or empty");
        Assert.hasLength(token, "token cannot be null or empty");
        this.headerName = headerName;
        this.parameterName = parameterName;
        this.token = token;
    }

    public String getHeaderName() {
        return this.headerName;
    }

    public String getParameterName() {
        return this.parameterName;
    }

    public String getToken() {
        return this.token;
    }
}
```
