-----
### 개요
-----
1. 최신 방식의 CSRF 공격 방어 방법 중 하나로서 서버가 쿠키를 설정할 때 SameSite 속성을 지정하여 크로스 사이트 간 쿠키 전송에 대한 제어를 핸들링 할 수 있음
2. Spring Security는 세션 쿠키의 생성을 직접 제어하지 않기 때문에, SameSite 속성에 대한 지원을 제공하지 않지만, Spring Session은 SameSite 속성을 지원

-----
### SameSite 속성
-----
1. Strict
   - 동일 사이트에서 오는 모든 요청에 쿠키가 포함되고 크로스 사이트 간 HTTP 요청에 쿠키가 포함되지 않음
<div align="center">
<img src="https://github.com/user-attachments/assets/6486517a-dce7-4e52-981d-f47b8fed5c17">
</div>

2. Lax (기본 설정)
   - 동일 사이트에서 오거나 Top Level Navigation에서 오는 요청 및 메소드가 읽기 전용인 경우 쿠키가 전송되고 그렇지 않으면 HTTP 요청에 쿠키가 포함되지 않음
   - 사용자가 링크(```<a>```)를 클릭하거나 window.location.replace, 302 Redirect 등의 이동이 포함
   - 그러나 ```<iframe>```이나 ```<img>```를 문서에 삽입, AJAX 통신 등은 쿠키가 전송되지 않음
<div align="center">
<img src="https://github.com/user-attachments/assets/b78f4154-2aa1-4214-8e12-8471f1aab89e">
</div>

3. None
   - 동일 사이트 및 크로스 사이트 요청의 경우에도 쿠키가 전송
   - 이 모드에서는 HTTS에 의한 Secure 쿠키로 설정되어야 함
<div align="center">
<img src="https://github.com/user-attachments/assets/d8064469-1e8c-4996-93d5-cec18877dd0c">
</div>

-----
### SameSite 예시
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/b3b28008-4794-40a2-b956-cc10f2a69a5f">
</div>

1. 대부분의 현대 브라우저는 SameSite 속성을 지원하지만, 여전히 사용 중인 오래된 브라우저는 지원하지 않을 수 있음
2. 💡 SameSite를 CSRF 공격에 대한 유일한 방어 수단으로서가 아니라 심층적으로 강화된 방어의 일환으로 사용하는 것을 권장하고 있음

-----
### Spring Session으로 SameSite 적용
-----
```gradle
implementation group: 'org.springframework.session', name: 'spring-session-core', version: '3.2.1'
```
```java
@Configuration
@EnableSpringHttpSession // JSESSIONID(WAS)가 아닌 SESSION(Spring Session)으로 발급
public class HttpSessionConfig {
    @Bean
    public CookieSerializer cookieSerializer() { // 세션 쿠키 생성
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();
        serializer.setUseSecureCooke(true); // 쿠키를 보안 쿠키로 사용
        serializer.setUseHttpOnlyCookie(true); // 쿠키를 HTTP 통신에만 사용
        serializer.setSameSite("Lax"); // SameSite 설정
        return serializer;
    }

    @Bean
    public SessionRepository<MapSession> sessionRepository() {
        return new MapSessionRepository(new ConcurrentHashMap<> ());
    }
}
```

-----
### 코드
-----
1. HttpSessionConfig
```java
package io.security.springsecuritymaster;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.session.MapSession;
import org.springframework.session.MapSessionRepository;
import org.springframework.session.SessionRepository;
import org.springframework.session.config.annotation.web.http.EnableSpringHttpSession;
import org.springframework.session.web.http.CookieSerializer;
import org.springframework.session.web.http.DefaultCookieSerializer;

import java.util.concurrent.ConcurrentHashMap;

@Configuration
@EnableSpringHttpSession
public class HttpSessionConfig {

    @Bean
    public CookieSerializer cookieSerializer() {
        DefaultCookieSerializer serializer = new DefaultCookieSerializer();

        serializer.setUseSecureCookie(true);
        serializer.setUseHttpOnlyCookie(true);
        serializer.setSameSite("None"); // Strict, Lax

        return serializer;
    }

    @Bean
    public SessionRepository<MapSession> sessionRepository() {
        return new MapSessionRepository(new ConcurrentHashMap<>());
    }
}
```
<div align="center">
<img src="https://github.com/user-attachments/assets/09c0d2f2-e030-4270-be84-f2172310e25d">
</div>
