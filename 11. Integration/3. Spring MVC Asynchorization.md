-----
### ê°œìš”
-----
1. ğŸ’¡ Spring SecurityëŠ” Spring MVC Controllerì—ì„œ Callableì„ ì‹¤í–‰í•˜ëŠ” ë¹„ë™ê¸° ìŠ¤ë ˆë“œì— SecurityContextë¥¼ ìë™ìœ¼ë¡œ ì„¤ì •í•˜ë„ë¡ ì§€ì› (Callableì€ ë³„ë„ì˜ ìŠ¤ë ˆë“œì—ì„œ ì‹¤í–‰ë˜ë„ë¡ ì„¤ì •ë˜ì–´ ìˆìŒ [ë¹„ë™ê¸° ì‹¤í–‰])
2. Spring SecurityëŠ” WebAsyncManagerì™€ í†µí•©í•˜ì—¬ SecurityContextHolderì—ì„œ ì‚¬ìš© ê°€ëŠ¥í•œ SecurityContextë¥¼ Callableì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë„ë¡ í•´ì¤Œ

-----
### WebAsyncManagerIntegrationFilter
-----
: SecurityContextì™€ WebAsyncManager ì‚¬ì´ì˜ í†µí•©ì„ ì œê³µí•˜ë©° WebAsyncManagerë¥¼ ìƒì„±í•˜ê³  SecurityContextCallableProcessingInterceptorë¥¼ WebAsyncManagerì— ë“±ë¡

-----
### WebAsyncManager
-----
: ìŠ¤ë ˆë“œ í’€ì˜ ë¹„ë™ê¸° ìŠ¤ë ˆë“œ(ìì‹ ìŠ¤ë ˆë“œ)ë¥¼ ìƒì„±í•˜ê³  Callableë¥¼ ë°›ì•„ ì‹¤í–‰ì‹œí‚¤ëŠ” ì£¼ì²´ë¡œì„œ ë“±ë¡ëœ SecurityContextCallablProcessingInterceptorë¥¼ í†µí•´ í˜„ì¬ ìŠ¤ë ˆë“œ(ë¶€ëª¨ ìŠ¤ë ˆë“œ)ê°€ ë³´ìœ í•˜ê³  ìˆëŠ” SecurityContext ê°ì²´ë¥¼ ë¹„ë™ê¸° ìŠ¤ë ˆë“œì˜ ThreadLocalì— ì €ì¥

-----
### ì½”ë“œ êµ¬í˜„
-----
<div align="center">
<img src="https://github.com/user-attachments/assets/5a319643-79e2-4a42-b184-42ad50749338">
</div>

  - Main Thread ì˜ì—­ : ë¶€ëª¨ Thread
  - ë¹„ë™ê¸° Thread ì˜ì—­ : ìì‹ Thread

1. ë¹„ë™ê¸° ìŠ¤ë ˆë“œê°€ ìˆ˜í–‰í•˜ëŠ” Callable ì˜ì—­ ë‚´ ìì‹ ì˜ ThreadLocalì— ì €ì¥ëœ SecurityContextë¥¼ ì°¸ì¡°í•  ìˆ˜ ìˆìœ¼ë©°, ì´ëŠ” ë¶€ëª¨ ìŠ¤ë ˆë“œê°€ ê°€ì§€ê³  ìˆëŠ” SecurityContextì™€ ë™ì¼í•œ ê°ì²´
2. ğŸ’¡ @Asyncë‚˜ ë‹¤ë¥¸ ë¹„ë™ê¸° ê¸°ìˆ ì€ ìŠ¤í”„ë§ ì‹œíë¦¬í‹°ì™€ í†µí•©ë˜ì–´ ìˆì§€ ì•Šê¸° ë•Œë¬¸ì—, ë¹„ë™ê¸° ìŠ¤ë ˆë“œì— SecurityContextê°€ ì ìš©ë˜ì§€ ì•ŠìŒ (ì¦‰, Callable ì‹¤í–‰ë§Œ ê°€ëŠ¥í•˜ë‹¤ëŠ” ì )

-----
### íë¦„ë„
----
<div align="center">
<img src="https://github.com/user-attachments/assets/fc21a5f7-69cb-4db2-9b2f-27e351910846">
</div>

-----
### ì½”ë“œ
-----
1. SecurityConfig
```java
package io.security.springsecuritymaster;

import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return (webSecurity) -> {
            webSecurity.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());
        };
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .authorizeHttpRequests(authorize -> authorize
                        .requestMatchers("/user").hasAuthority("ROLE_USER")
                        .requestMatchers("/db").hasAuthority("ROLE_DB")
                        .requestMatchers("/admin").hasAuthority("ROLE_ADMIN")
                        .anyRequest().permitAll())
                .formLogin(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable);

        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService(){
        UserDetails user = User.withUsername("user").password("{noop}1111").roles("USER").build();
        UserDetails db = User.withUsername("db").password("{noop}1111").roles("DB").build();
        UserDetails admin = User.withUsername("admin").password("{noop}1111").roles("ADMIN","SECURE").build();
        return  new InMemoryUserDetailsManager(user, db, admin);
    }
}
```

2. IndexController
```java
package io.security.springsecuritymaster;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.Callable;

@RestController
@RequiredArgsConstructor
public class IndexController {

    @GetMapping("/")
    public String index() {
        return "index";
    }

    @GetMapping("/user")
    public String user() {
        return "user";
    }

    @GetMapping("/db")
    public String db(){
        return "db";
    }

    @GetMapping("/admin")
    public String admin(){
        return "admin";
    }

    @GetMapping("/callable")
    public Callable<Authentication> callable() { // ë¶€ëª¨ ìŠ¤ë ˆë“œ
        SecurityContext securityContext = SecurityContextHolder.getContextHolderStrategy().getContext();
        System.out.println("securityContext = " + securityContext);
        System.out.println("Parent Thread = " + Thread.currentThread().getName());

        return new Callable<Authentication>() { // ë¹„ë™ê¸° ìŠ¤ë ˆë“œ
            @Override
            public Authentication call() throws Exception {
                SecurityContext securityContext = SecurityContextHolder.getContextHolderStrategy().getContext(); // ë¶€ëª¨ ìŠ¤ë ˆë“œì™€ SecurityContext ê³µìœ 
                System.out.println("securityContext = " + securityContext);
                System.out.println("Parent Thread = " + Thread.currentThread().getName());
                return securityContext.getAuthentication();
            }
        };
    }
}
```
```
securityContext = SecurityContextImpl [Authentication=UsernamePasswordAuthenticationToken [Principal=org.springframework.security.core.userdetails.User [Username=user, Password=[PROTECTED], Enabled=true, AccountNonExpired=true, CredentialsNonExpired=true, AccountNonLocked=true, Granted Authorities=[ROLE_USER]], Credentials=[PROTECTED], Authenticated=true, Details=WebAuthenticationDetails [RemoteIpAddress=127.0.0.1, SessionId=null], Granted Authorities=[ROLE_USER]]]
Parent Thread = http-nio-9090-exec-5
securityContext = SecurityContextImpl [Authentication=UsernamePasswordAuthenticationToken [Principal=org.springframework.security.core.userdetails.User [Username=user, Password=[PROTECTED], Enabled=true, AccountNonExpired=true, CredentialsNonExpired=true, AccountNonLocked=true, Granted Authorities=[ROLE_USER]], Credentials=[PROTECTED], Authenticated=true, Details=WebAuthenticationDetails [RemoteIpAddress=127.0.0.1, SessionId=null], Granted Authorities=[ROLE_USER]]]
Child Thread = task-1
```
  - Security Contextê°€ ë™ì¼

3. ë‹¤ë¥¸ ë¹„ë™ê¸° ê¸°ìˆ  ì‚¬ìš©
  - IndexController
```java
package io.security.springsecuritymaster;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.concurrent.Callable;

@RestController
@RequiredArgsConstructor
public class IndexController {
    private final AsyncService asyncService;

    @GetMapping("/")
    public String index() {
        return "index";
    }

    @GetMapping("/user")
    public String user() {
        return "user";
    }

    @GetMapping("/db")
    public String db(){
        return "db";
    }

    @GetMapping("/admin")
    public String admin(){
        return "admin";
    }

    @GetMapping("/callable")
    public Callable<Authentication> callable() { // ë¶€ëª¨ ìŠ¤ë ˆë“œ
        SecurityContext securityContext = SecurityContextHolder.getContextHolderStrategy().getContext();
        System.out.println("securityContext = " + securityContext);
        System.out.println("Parent Thread = " + Thread.currentThread().getName());

        return new Callable<Authentication>() { // ë¹„ë™ê¸° ìŠ¤ë ˆë“œ
            @Override
            public Authentication call() throws Exception {
                SecurityContext securityContext = SecurityContextHolder.getContextHolderStrategy().getContext(); // ë¶€ëª¨ ìŠ¤ë ˆë“œì™€ SecurityContext ê³µìœ 
                System.out.println("securityContext = " + securityContext);
                System.out.println("Child Thread = " + Thread.currentThread().getName());
                return securityContext.getAuthentication();
            }
        };
    }
    
    @GetMapping("/async")
    public Authentication async() {
        SecurityContext securityContext = SecurityContextHolder.getContextHolderStrategy().getContext();
        System.out.println("securityContext = " + securityContext);
        System.out.println("Parent Thread = " + Thread.currentThread().getName());
        
        asyncService.asyncMethod();
        
        return securityContext.getAuthentication();
    }
}
```

  - AsyncService
```java
package io.security.springsecuritymaster;

import org.springframework.scheduling.annotation.Async;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

@Service
public class AsyncService {
    
    @Async // ë¹„ë™ê¸° ì‹¤í–‰
    public void asyncMethod() {
        SecurityContext securityContext = SecurityContextHolder.getContextHolderStrategy().getContext(); // ë¶€ëª¨ ìŠ¤ë ˆë“œì™€ SecurityContext ê³µìœ 
        System.out.println("securityContext = " + securityContext);
        System.out.println("Child Thread = " + Thread.currentThread().getName());
    }
}
```

  - SpringsecuritymasterApplication
```java
package io.security.springsecuritymaster;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

@SpringBootApplication
@EnableAsync // ë¹„ë™ê¸° ìŠ¤ë ˆë“œê°€ ì‘ë™í•˜ê¸° ìœ„í•´ ì„¤ì •
public class SpringsecuritymasterApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringsecuritymasterApplication.class, args);
	}

}
```

```
securityContext = SecurityContextImpl [Authentication=UsernamePasswordAuthenticationToken [Principal=org.springframework.security.core.userdetails.User [Username=user, Password=[PROTECTED], Enabled=true, AccountNonExpired=true, CredentialsNonExpired=true, AccountNonLocked=true, Granted Authorities=[ROLE_USER]], Credentials=[PROTECTED], Authenticated=true, Details=WebAuthenticationDetails [RemoteIpAddress=0:0:0:0:0:0:0:1, SessionId=null], Granted Authorities=[ROLE_USER]]]
Parent Thread = http-nio-9090-exec-7
securityContext = SecurityContextImpl [Null authentication]
Child Thread = task-1
```

  - SecurityConfig
```java
package io.security.springsecuritymaster;

import org.springframework.boot.autoconfigure.security.servlet.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityCustomizer;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;

@EnableWebSecurity
@Configuration
public class SecurityConfig {

    @Bean
    public WebSecurityCustomizer webSecurityCustomizer() {
        return (webSecurity) -> {
            webSecurity.ignoring().requestMatchers(PathRequest.toStaticResources().atCommonLocations());
        };
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {

        http
                .authorizeHttpRequests(authorize -> authorize
                        .requestMatchers("/user").hasAuthority("ROLE_USER")
                        .requestMatchers("/db").hasAuthority("ROLE_DB")
                        .requestMatchers("/admin").hasAuthority("ROLE_ADMIN")
                        .anyRequest().permitAll())
                .formLogin(Customizer.withDefaults())
                .csrf(AbstractHttpConfigurer::disable);

        SecurityContextHolder.setStrategyName(SecurityContextHolder.MODE_INHERITABLETHREADLOCAL); // ë¶€ëª¨ - ìì‹ SecurityContext ê³µìœ  ê°€ëŠ¥
        return http.build();
    }

    @Bean
    public UserDetailsService userDetailsService(){
        UserDetails user = User.withUsername("user").password("{noop}1111").roles("USER").build();
        UserDetails db = User.withUsername("db").password("{noop}1111").roles("DB").build();
        UserDetails admin = User.withUsername("admin").password("{noop}1111").roles("ADMIN","SECURE").build();
        return  new InMemoryUserDetailsManager(user, db, admin);
    }
}
```
```
securityContext = SecurityContextImpl [Authentication=UsernamePasswordAuthenticationToken [Principal=org.springframework.security.core.userdetails.User [Username=user, Password=[PROTECTED], Enabled=true, AccountNonExpired=true, CredentialsNonExpired=true, AccountNonLocked=true, Granted Authorities=[ROLE_USER]], Credentials=[PROTECTED], Authenticated=true, Details=WebAuthenticationDetails [RemoteIpAddress=0:0:0:0:0:0:0:1, SessionId=null], Granted Authorities=[ROLE_USER]]]
Parent Thread = http-nio-9090-exec-7
securityContext = SecurityContextImpl [Authentication=UsernamePasswordAuthenticationToken [Principal=org.springframework.security.core.userdetails.User [Username=user, Password=[PROTECTED], Enabled=true, AccountNonExpired=true, CredentialsNonExpired=true, AccountNonLocked=true, Granted Authorities=[ROLE_USER]], Credentials=[PROTECTED], Authenticated=true, Details=WebAuthenticationDetails [RemoteIpAddress=0:0:0:0:0:0:0:1, SessionId=null], Granted Authorities=[ROLE_USER]]]
Child Thread = task-1
```

4. ì²˜ë¦¬ ê³¼ì •
   - WebAsyncManagerIntegrationFilter
```java
protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); // WebAsyncManager ìƒì„±
        SecurityContextCallableProcessingInterceptor securityProcessingInterceptor = (SecurityContextCallableProcessingInterceptor)asyncManager.getCallableInterceptor(CALLABLE_INTERCEPTOR_KEY);
        if (securityProcessingInterceptor == null) {
            SecurityContextCallableProcessingInterceptor interceptor = new SecurityContextCallableProcessingInterceptor(); // SecurityContextCallableProcessingInterceptorê°€ Nullì¼ ê²½ìš°, ìƒì„± í›„, WebAsyncManagerì— ë“±ë¡
            interceptor.setSecurityContextHolderStrategy(this.securityContextHolderStrategy); // SecurityContextCallableProcessingInterceptorì— ë¶€ëª¨ í´ë˜ìŠ¤ - ìì‹ í´ë˜ìŠ¤ SecurityContext ê°ì²´ë¥¼ Interceptorì— ì„¤ì ˆ
            asyncManager.registerCallableInterceptor(CALLABLE_INTERCEPTOR_KEY, interceptor); // ë“±ë¡
        }

        filterChain.doFilter(request, response);
}
```

  - SecurityContextCallableProcessingInterceptor
```java
public <T> void beforeConcurrentHandling(NativeWebRequest request, Callable<T> task) {
        if (this.securityContext == null) {
            this.setSecurityContext(this.securityContextHolderStrategy.getContext()); // í˜„ì¬ ì‹¤í–‰ ì¤‘ì¸ ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ SecurityContextë¥¼ ì €ì¥
        }
}

private void setSecurityContext(SecurityContext securityContext) {
        this.securityContext = securityContext;
}
```

  - WebAsyncManager
```java
public void startCallableProcessing(final WebAsyncTask<?> webAsyncTask, Object... processingContext) throws Exception {
        Assert.notNull(webAsyncTask, "WebAsyncTask must not be null");
        Assert.state(this.asyncWebRequest != null, "AsyncWebRequest must not be null");
        if (!this.state.compareAndSet(WebAsyncManager.State.NOT_STARTED, WebAsyncManager.State.ASYNC_PROCESSING)) {
            throw new IllegalStateException("Unexpected call to startCallableProcessing: [" + this.state.get() + "]");
        } else {
            Long timeout = webAsyncTask.getTimeout();
            if (timeout != null) {
                this.asyncWebRequest.setTimeout(timeout);
            }

            AsyncTaskExecutor executor = webAsyncTask.getExecutor();
            if (executor != null) {
                this.taskExecutor = executor;
            }

            List<CallableProcessingInterceptor> interceptors = new ArrayList();
            interceptors.add(webAsyncTask.getInterceptor());
            interceptors.addAll(this.callableInterceptors.values());
            interceptors.add(timeoutCallableInterceptor);
            Callable<?> callable = webAsyncTask.getCallable();
            CallableInterceptorChain interceptorChain = new CallableInterceptorChain(interceptors);
            this.asyncWebRequest.addTimeoutHandler(() -> {
                if (logger.isDebugEnabled()) {
                    logger.debug("Servlet container timeout notification for " + formatUri(this.asyncWebRequest));
                }

                Object result = interceptorChain.triggerAfterTimeout(this.asyncWebRequest, callable);
                if (result != CallableProcessingInterceptor.RESULT_NONE) {
                    this.setConcurrentResultAndDispatch(result);
                }

            });
            this.asyncWebRequest.addErrorHandler((exx) -> {
                if (logger.isDebugEnabled()) {
                    Log var10000 = logger;
                    String var10001 = formatUri(this.asyncWebRequest);
                    var10000.debug("Servlet container error notification for " + var10001 + ": " + exx);
                }

                Object result = interceptorChain.triggerAfterError(this.asyncWebRequest, callable, exx);
                result = result != CallableProcessingInterceptor.RESULT_NONE ? result : exx;
                this.setConcurrentResultAndDispatch(result);
            });
            this.asyncWebRequest.addCompletionHandler(() -> {
                interceptorChain.triggerAfterCompletion(this.asyncWebRequest, callable);
            });
            interceptorChain.applyBeforeConcurrentHandling(this.asyncWebRequest, callable);
            this.startAsyncProcessing(processingContext);

            try { // ìŠ¤ë ˆë“œ í’€ì„ í†µí•´ ë³„ë„ì˜ ìŠ¤ë ˆë“œë¥¼ ìƒì„±
                Future<?> future = this.taskExecutor.submit(() -> {
                    // ë¹„ë™ê¸° ìŠ¤ë ˆë“œ ì²˜ë¦¬
                    Object result = null;

                    try {
                        interceptorChain.applyPreProcess(this.asyncWebRequest, callable); // ë¶€ëª¨ ìŠ¤ë ˆë“œì˜ SecurityContextë¥¼ ìì‹ ìŠ¤ë ˆë“œì—ë„ ì €ì¥
                        result = callable.call(); // callable : ë¹„ë™ê¸° ìŠ¤ë ˆë“œ
                    } catch (Throwable var8) {
                        Throwable ex = var8;
                        result = ex;
                    } finally {
                        result = interceptorChain.applyPostProcess(this.asyncWebRequest, callable, result);
                    }

                    this.setConcurrentResultAndDispatch(result);
                });
                interceptorChain.setTaskFuture(future);
            } catch (Throwable var10) {
                Throwable ex = var10;
                Object result = interceptorChain.applyPostProcess(this.asyncWebRequest, callable, ex);
                this.setConcurrentResultAndDispatch(result);
            }

        }
}
```
